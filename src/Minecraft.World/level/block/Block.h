#pragma once

#include <memory>
#include <string>
#include <vector>
#include "types.h"

typedef unsigned char uchar;

class AABB;
class BlockEntity;
class BlockPos;
class BlockState;
class BlockStateDefinition;
class BlockTooltipDataHolder;
class Direction;
class Entity;
class Explosion;
class HtmlString;
class IconRegister;
class InteractionHand {
public:
    enum EInteractionHand {};
};
class ItemInstance;
class Level;
class LevelSource;
class LivingEntity;
class Material;
class MaterialColor;
class Mirror;
class Player;
class Random;
class Rotation;
class SoundType;
class Texture;
class Vec3;

class Block {
public:
    Block(Material*);
    virtual void isTopSolidBlocking(BlockState const*);
    virtual void isValidSpawn(BlockState const*, std::shared_ptr<Entity>);
    virtual void ParticlesSurviveWithin(void);
    virtual void GetInteractTooltip(BlockTooltipDataHolder const&);
    virtual void GetHitTooltip(BlockTooltipDataHolder const&);
    virtual void getMapColor(BlockState const*, LevelSource*, BlockPos const&);
    virtual void getBlockState(int);
    virtual void convertBlockStateToLegacyData(BlockState const*);
    virtual void fillVirtualBlockStateProperties(BlockState const*, LevelSource*, BlockPos const&);
    virtual void rotate(BlockState const*, Rotation*);
    virtual void mirror(BlockState const*, Mirror*);
    virtual ~Block();
    virtual void DerivedInit(void);
    virtual void sendBlockData(uchar);
    virtual void setSoundType(SoundType const*);
    virtual void setLightBlock(int);
    virtual void setLightEmission(float);
    virtual void setExplodeable(float);
    virtual void isSolidBlockingCube(BlockState const*);
    virtual void isSolidBlockingCubeAndNotSignalSource(BlockState const*);
    virtual void isViewBlocking(BlockState const*);
    virtual void isCubeShaped(BlockState const*);
    virtual void hasCustomBreakingProgress(BlockState const*);
    virtual void isPathfindable(LevelSource*, BlockPos const&);
    virtual void getRenderShape(BlockState const*);
    virtual void hasInHandRenderOffset(void);
    virtual void mayReplaceWithPlace(LevelSource*, BlockPos const&);
    virtual void setDestroyTime(float);
    virtual void setIndestructible(void);
    virtual void isIndestructible(void);
    virtual void getDestroySpeed(BlockState const*, Level*, BlockPos const&);
    virtual void setTicking(bool);
    virtual void disableMipmap(void);
    virtual void setSemiTransparent(void);
    virtual void isTicking(void);
    virtual void getShape(BlockState const*, LevelSource*, BlockPos const&);
    virtual void getLightColor(BlockState const*, LevelSource*, BlockPos const&, int);
    virtual void shouldRenderFace(BlockState const*, LevelSource*, BlockPos const&, Direction const*);
    virtual void getShapes(BlockState const*, LevelSource*, BlockPos const*);
    virtual void isSolidFace(LevelSource*, BlockPos const&, Direction const*);
    virtual void getBlockFaceShape(LevelSource*, BlockState const*, BlockPos const&, Direction const*);
    virtual void getOutlineAABB(BlockState const*, Level*, BlockPos const&);
    virtual void addCollisionAABBs(BlockState const*, Level*, BlockPos const&, AABB const*, std::vector<AABB*>*, std::shared_ptr<Entity>, bool);
    virtual void addCollisionAABB(BlockPos const&, AABB const*, std::vector<AABB*>*, AABB const*);
    virtual void getClipAABB(BlockState const*, LevelSource*, BlockPos const&);
    virtual void isSolidRender(BlockState const*);
    virtual void mayPick(BlockState const*, bool);
    virtual void mayPick(void);
    virtual void randomTick(Level*, BlockPos const&, BlockState const*, Random*);
    virtual void tick(Level*, BlockPos const&, BlockState const*, Random*);
    virtual void animateTick(BlockState const*, Level*, BlockPos const&, Random*);
    virtual void destroy(Level*, BlockPos const&, BlockState const*);
    virtual void neighborChanged(BlockState const*, Level*, BlockPos const&, Block*, BlockPos const&);
    virtual void addLights(Level*, BlockPos const&);
    virtual void getTickDelay(Level*);
    virtual void onPlace(Level*, BlockPos const&, BlockState const*);
    virtual void onRemove(Level*, BlockPos const&, BlockState const*);
    virtual void getResourceCount(Random*);
    virtual void getResource(BlockState const*, Random*, int);
    virtual void getDestroyProgress(BlockState const*, std::shared_ptr<Player>, Level*, BlockPos const&);
    virtual void spawnResources(Level*, BlockPos const&, BlockState const*, int);
    virtual void spawnResources(Level*, BlockPos const&, BlockState const*, float, int);
    virtual void popExperience(Level*, BlockPos const&, int);
    virtual void getSpawnResourcesAuxValue(BlockState const*);
    virtual void getExplosionResistance(std::shared_ptr<Entity>);
    virtual void clip(BlockState const*, Level*, BlockPos const&, Vec3*, Vec3*);
    virtual void clip(BlockPos const&, Vec3*, Vec3*, AABB const*);
    virtual void wasExploded(Level*, BlockPos const&, Explosion*);
    virtual void getRenderLayer(void);
    virtual void mayPlace(Level*, BlockPos const&, Direction const*);
    virtual void mayPlace(Level*, BlockPos const&);
    virtual void TestUse(void);
    virtual void TestUse(Level*, BlockPos const&, BlockState const*, std::shared_ptr<Player>);
    virtual void use(Level*, BlockPos const&, BlockState const*, std::shared_ptr<Player>, InteractionHand::EInteractionHand, Direction const*, float, float, float, bool);
    virtual void stepOn(Level*, BlockPos const&, std::shared_ptr<Entity>);
    virtual void getStateForPlacement(Level*, BlockPos const&, Direction const*, float, float, float, int, std::shared_ptr<LivingEntity>);
    virtual void prepareRender(Level*, BlockPos const&);
    virtual void attack(Level*, BlockPos const&, std::shared_ptr<Player>);
    virtual void handleEntityInside(Level*, BlockPos const&, std::shared_ptr<Entity>, Vec3*);
    virtual void getColor(void);
    virtual void getColor(BlockState const*);
    virtual void getColor(LevelSource*, BlockPos const&, int);
    virtual void getColor(LevelSource*, BlockPos const&);
    virtual void getColor(LevelSource*, BlockPos const&, BlockState const*);
    virtual void getSignal(BlockState const*, LevelSource*, BlockPos const&, Direction const*);
    virtual void isSignalSource(BlockState const*);
    virtual void entityInside(Level*, BlockPos const&, BlockState const*, std::shared_ptr<Entity> const&);
    virtual void getDirectSignal(BlockState const*, LevelSource*, BlockPos const&, Direction const*);
    virtual void playerDestroy(Level*, std::shared_ptr<Player>, BlockPos const&, BlockState const*, std::shared_ptr<BlockEntity>, not_null_ptr<ItemInstance>);
    virtual void isSilkTouchable(void);
    virtual void getSilkTouchItemInstance(BlockState const*);
    virtual void getResourceCountForLootBonus(int, Random*);
    virtual void setPlacedBy(Level*, BlockPos const&, BlockState const*, std::shared_ptr<LivingEntity>, not_null_ptr<ItemInstance>);
    virtual void setNameAndDescriptionId(int, int);
    virtual void isPossibleToRespawnInThis(void);
    virtual void getName(void);
    virtual void getDescriptionId(int);
    virtual void getUseDescriptionId(void);
    virtual void triggerEvent(BlockState const*, Level*, BlockPos const&, int, int);
    virtual void isCollectStatistics(void);
    virtual void shouldBlockTick(Level*, BlockPos const&, BlockState const*);
    virtual void setNotCollectStatistics(void);
    virtual void getPistonPushReaction(BlockState const*);
    virtual void getShadeBrightness(BlockState const*);
    virtual void fallOn(Level*, BlockPos const&, std::shared_ptr<Entity>, float);
    virtual void updateEntityAfterFallOn(Level*, std::shared_ptr<Entity>);
    virtual void getCloneItemInstance(Level*, BlockPos const&, BlockState const*);
    virtual void playerWillDestroy(Level*, BlockPos const&, BlockState const*, std::shared_ptr<Player>);
    virtual void handleRain(Level*, BlockPos const&);
    virtual void canInstantlyTick(void);
    virtual void dropFromExplosion(Explosion*);
    virtual void isMatching(Block*);
    virtual void hasAnalogOutputSignal(BlockState const*);
    virtual void getAnalogOutputSignal(BlockState const*, Level*, BlockPos const&);
    virtual void setIconName(std::wstring const&);
    virtual void getIconName(void);
    virtual void registerIcons(IconRegister*);
    virtual void getTileItemIconName(void);
    virtual void getIconTexture(Direction const*, BlockState const*);
    virtual void getTexture(LevelSource*, BlockPos const&, Direction const*, BlockState const*);
    virtual void getTexture(Direction const*, BlockState const*);
    virtual void getTexture(Direction const*);
    virtual void getInventoryRenderState(BlockState const*);
    virtual void createBlockStateDefinition(void);
    virtual void getBlockStateDefinition(void);
    virtual void getOffsetType(void);
    virtual void getOffset(BlockState const*, LevelSource*, BlockPos const&);
    virtual void getSoundType(void);
    virtual void toString(void);
    virtual void appendHoverText(not_null_ptr<ItemInstance>, std::shared_ptr<Player>, std::vector<HtmlString>*, bool);
    virtual void isLiquidBlock(void);

    int field_8;
    bool field_C;
    std::wstring mItemName;
    int field_24;
    bool field_28;
    int lightEmission;
    bool isBlocksLight;
    int mLightEmission;
    bool field_3C;
    bool isDisableMipmap;
    bool field_3E;
    bool isSemiTransparent;
    float mDestroyTime;
    float mExplosionResistance;
    bool mIsCollectStatistics;
    bool mIsTicking;
    bool mIsSilkTouchable;
    bool field_4B;
    int mMaterialType;
    int mBaseItemType;
    char isInited;
    const SoundType* mSoundType;
    float field_60;
    Material* mMaterial;
    MaterialColor* mMapColor;
    float mFriction;
    BlockStateDefinition* mBlockStateDefinition;
    BlockState* mBlockState;
    int mDescriptionId;
    int mUseDescriptionId;
    Texture* mTexture;
    int field_A0;
};

ASSERT_SIZEOF(Block, 0xA8)