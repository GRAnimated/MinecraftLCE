#pragma once

#include "net/minecraft/core/NonNullList.h"
#include "net/minecraft/world/InteractionHand.h"
#include "net/minecraft/world/entity/Entity.h"
#include "net/minecraft/world/entity/MobType.h"
#include "net/minecraft/world/item/ItemInstance.h"
#include "net/minecraft/world/item/enchantment/Enchantment.h"
#include "net/minecraft/world/level/Level.h"
#include "types.h"
#include <unordered_map>

class AttributeMap;
class Attribute;
class MobEffect;
class MobEffectInstance;
class CombatTracker;
class ThermalAreaRuleDefinition;
class HumanoidArm;

class LivingEntity : public Entity {
public:
    LivingEntity(Level* level);

    int getUseItemRemainingTicks();

    eINSTANCEOF GetType() override;
    void fjDerivedCtorCalls() override;
    void kill() override;
    void defineSynchedData() override;
    void tick() override;
    void baseTick() override;
    void outOfWorld() override;
    void checkFallDamage(double, bool, Block*, const BlockPos&) override;
    void causeFallDamage(float, float) override;
    void getLightColor() override;
    void markHurt() override;
    void hurt(DamageSource*, float) override;
    Vec3* getViewVector(float) override;
    bool isPickable() override;
    bool isPushable() override;
    void readAdditionalSaveData(CompoundTag*) override;
    void addAdditonalSaveData(CompoundTag*) override;
    bool isAlive() override;
    void rideTick() override;
    void stopRiding() override;
    void lerpTo(double, double, double, float, float, int, bool) override;
    void handleEntityEvent(unsigned char, int) override;
    void animateHurt() override;
    virtual NonNullList<not_null_ptr<ItemInstance>> getArmorSlots() = 0;
    virtual void setItemSlot(const EquipmentSlot*, not_null_ptr<ItemInstance>) = 0;
    void setSprinting(bool) override;
    Team* getTeam() override;
    void spawnEatParticles(const ItemInstance&, int) override;
    void getYHeadRot() override;
    void setYHeadRot(float) override;
    void setYBodyRot(float) override;
    void shouldShowName() override;
    void onSyncedDataUpdated(const EntityDataAccessor_Base*) override;
    void setBoundingBox(AABB* box) override;
    void stopCurrentLerp() override;
    virtual void registerAttributes();
    virtual bool isWaterMob();
    virtual void onChangedBlock(const BlockPos&);
    virtual bool isBaby();
    virtual void tickDeath();
    virtual void shouldDropExperience();
    virtual void decreaseAirSupply(int);
    virtual void getExperienceReward(std::shared_ptr<Player>);
    virtual bool isAlwaysExperienceDropper();
    virtual Random* getRandom();
    virtual void getLastHurtByMob();
    virtual void getLastHurtByMobTimestamp();
    virtual void setLastHurtByMob(std::shared_ptr<LivingEntity>);
    virtual void getLastHurtMob();
    virtual void getLastHurtMobTimestamp();
    virtual void setLastHurtMob(std::shared_ptr<Entity>);
    virtual void getNoActionTime();
    virtual void tickEffects();
    virtual void updateInvisibilityStatus();
    virtual void removeEffectParticles();
    virtual void removeAllEffects();
    virtual void getActiveEffects();
    virtual bool hasEffect(MobEffect*);
    virtual MobEffectInstance* getEffect(MobEffect*);
    virtual void addEffect(MobEffectInstance*, const std::shared_ptr<Entity>&);
    virtual void addEffectNoUpdate(MobEffectInstance*);
    virtual void canBeAffected(MobEffectInstance*);
    virtual bool isInvertedHealAndHarm();
    virtual void removeEffectNoUpdate(MobEffect*);
    virtual void removeEffect(MobEffect*);
    virtual void onEffectAdded(MobEffectInstance*);
    virtual void onEffectUpdated(MobEffectInstance*, bool);
    virtual void onEffectRemoved(MobEffectInstance*);
    virtual void heal(float);
    virtual void getHealth();
    virtual void setHealth(float);
    virtual void getLastDamageSource();
    virtual void blockUsingShield(const std::shared_ptr<LivingEntity>&);
    virtual void playHurtSound(DamageSource*);
    virtual void checkTotemDeathProtection(DamageSource*);
    virtual bool isDamageSourceBlocked(DamageSource*);
    virtual void breakItem(not_null_ptr<ItemInstance>);
    virtual void die(DamageSource*);
    virtual void dropEquipment(bool, int);
    virtual void knockback(std::shared_ptr<Entity>, float, double, double);
    virtual void getHurtSound(DamageSource*);
    virtual void getDeathSound();
    virtual void getFallDamageSound(int);
    virtual void dropAllDeathLoot(bool, int, DamageSource*);
    virtual void dropDeathLoot(bool, int);
    virtual bool onLadder();
    virtual bool isShootable();
    virtual void getArmorValue();
    virtual void hurtArmor(float);
    virtual void hurtCurrentlyUsedShield(float);
    virtual void getDamageAfterArmorAbsorb(DamageSource, float);
    virtual void getDamageAfterMagicAbsorb(DamageSource, float);
    virtual void actuallyHurt(DamageSource, float);
    virtual void getCombatTracker();
    virtual void getKillCredit();
    virtual void getMaxHealth();
    virtual void getArrowCount();
    virtual void setArrowCount(int);
    virtual void swing(InteractionHand::EInteractionHand);
    virtual void updateSwingTime();
    virtual Attribute* getAttribute(Attribute* attribute);
    virtual AttributeMap* getAttributes();
    virtual MobType getMobType();
    virtual not_null_ptr<ItemInstance> getMainHandItem();
    virtual not_null_ptr<ItemInstance> getOffhandItem();
    virtual not_null_ptr<ItemInstance> getItemInHand(InteractionHand::EInteractionHand);
    virtual void setItemInHand(InteractionHand::EInteractionHand, not_null_ptr<ItemInstance>);
    virtual bool hasItemInSlot(const EquipmentSlot*);
    virtual not_null_ptr<ItemInstance> getItemSlot(const EquipmentSlot*) = 0;
    virtual void getItemInHandIcon(not_null_ptr<ItemInstance>, int);
    virtual void getSoundVolume();
    virtual void getVoicePitch();
    virtual bool isImmobile();
    virtual void findStandUpPosition(std::shared_ptr<Entity>);
    virtual void getJumpPower();
    virtual void jumpFromGround();
    virtual void jumpInWater();
    virtual void jumpInLava();
    virtual float getWaterSlowDown();
    virtual void travel(float, float, float);
    virtual void updateModelAnimation();
    virtual float getSpeed();
    virtual void setSpeed(float);
    virtual void doHurtTarget(std::shared_ptr<Entity>);
    virtual bool isSleeping();
    virtual void tickHeadTurn(float, float);
    virtual void aiStep();
    virtual void serverAiStep();
    virtual void pushEntities();
    virtual void doPush(std::shared_ptr<Entity>);
    virtual void setJumping(bool);
    virtual void take(std::shared_ptr<Entity>, int);
    virtual bool canSee(std::shared_ptr<Entity>);
    virtual float getAttackAnim(float a2);
    virtual const AABB* getSweptVolume();
    virtual bool isEffectiveAi();
    virtual float getAbsorptionAmount();
    virtual void setAbsorptionAmount(float amount);
    virtual void onEnterCombat();
    virtual void onLeaveCombat();
    virtual void updateEffectVisibility();
    virtual HumanoidArm* getMainArm() = 0;
    virtual bool isUsingItem();
    virtual InteractionHand::EInteractionHand getUsedItemHand();
    virtual void updatingUsingItem();
    virtual void startUsingItem(InteractionHand::EInteractionHand);
    virtual void spawnItemUseParticles(not_null_ptr<ItemInstance>, int);
    virtual void completeUsingItem();
    virtual int getTicksUsingItem();
    virtual void releaseUsingItem();
    virtual void releaseUsingItem(int);
    virtual void stopUsingItem();
    virtual bool isBlocking();
    virtual bool isFallFlying();
    virtual void getFallFlyingTicks();
    virtual bool isAffectedByPotions();
    virtual void attackable();
    virtual void setRecordPlayingNearby(const BlockPos&, bool);
    virtual bool IsCreativeFlying();

    void init();
    void CheckThermalAreas();
    static void fallFlyingTravel(double&, double&, double&, Vec3*, float&, float&, double&, double);
    not_null_ptr<ItemInstance> getUseItem();
    void activateElytraSpeedBoost(double);

    Attribute* m_attributes;
    CombatTracker* m_combatTracker;
    std::unordered_map<MobEffect*, MobEffectInstance*> m_activePotionsMap;
    NonNullList<not_null_ptr<ItemInstance>> m_lastHandItemStacks;
    NonNullList<not_null_ptr<ItemInstance>> m_lastArmorItemStacks;
    bool m_isSwinging;
    InteractionHand::EInteractionHand m_swingingArm;
    int m_swingTime;
    int m_swingTime2;
    int m_removeArrowTime;
    int m_hurtTime;
    int m_hurtDuration;
    float m_hurtDir;
    int m_deathTime;
    float m_oAttackAnim;
    float m_attackAnim;
    int m_attackStrengthTicker;
    float m_animationSpeedOld;
    float m_animationSpeed;
    float m_animationPosition;
    int m_dword36C;
    float m_tilto;
    float m_tilt;
    float m_randomUnused2;
    float m_randomUnused1;
    float m_yBodyRot;
    float m_yBodyRotO;
    float m_yHeadRot;
    float m_yHeadRotO;
    float m_flyingSpeed;
    double m_additionalGlideVelocity;
    double m_appliedLiftVelocity;
    bool m_isApplyingLift;
    int m_liftDurationTimer;
    double m_targetLiftVelocity;
    bool m_isUpdraft;
    double m_staticLiftTargetHeight;
    bool m_isApplyingStaticLift;
    bool m_isSpeedBoosting;
    double m_targetBoostSpeed;
    ThermalAreaRuleDefinition* m_thermalArea;
    bool m_bool3E0;
    bool m_hasPendingThermalEntry;
    void* m_qword3E8;
    bool m_isInThermalArea;
    int m_dword3F4;
    char m_gap3F8[24];
    bool m_bool410;
    std::shared_ptr<Player> m_lastHurtByPlayer;
    int m_lastHurtByPlayerTime;
    int m_isDead;
    int m_noActionTime;
    float m_oRun;
    float m_run;
    float m_animStep;
    float m_oAnimStep;
    float m_rotOffs;
    int m_deathScore;
    float m_lastHurt;
    bool m_isJumping;
    float m_xxa;
    float m_yya;
    float m_zza;
    float m_yRotA;
    int m_lerpSteps;
    double m_lerpX;
    double m_lerpY;
    double m_lerpZ;
    double m_lerpYRot;
    double m_lerpXRot;
    bool m_areEffectsDirty;
    std::shared_ptr<LivingEntity> m_lastHurtByMob;
    int m_lastHurtByMobTimestamp;
    std::shared_ptr<LivingEntity> m_lastHurtMob;
    int m_lastHurtMobTimestamp;
    float m_speed;
    int m_noJumpDelay;
    float m_absorptionAmount;
    not_null_ptr<ItemInstance> m_useItem;
    int m_useItemRemaining;
    int m_fallFlyTicks;
    BlockPos m_lastPos;
    DamageSource* m_lastDamageSource;
    long m_lastDamageStamp;
    bool m_bool508;
    int m_boundingBoxUpdateCount;
    int m_minX;
    int m_maxX;
    int m_minY;
    int m_maxY;
    int m_minZ;
    int m_maxZ;
    char m_gap528[128];
    char m_bool5A8;
    int m_dword5Ac;
};
